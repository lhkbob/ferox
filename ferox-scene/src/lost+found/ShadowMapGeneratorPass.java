/*
 * Ferox, a graphics and game library in Java
 *
 * Copyright (c) 2012, Michael Ludwig
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 *     Redistributions of source code must retain the above copyright notice,
 *         this list of conditions and the following disclaimer.
 *     Redistributions in binary form must reproduce the above copyright notice,
 *         this list of conditions and the following disclaimer in the
 *         documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.ferox.scene.controller.ffp;

import com.ferox.entity2.Entity;
import com.ferox.math.bounds.Frustum;
import com.ferox.renderer.FixedFunctionRenderer;
import com.ferox.renderer.Surface;
import com.ferox.renderer.Renderer.DrawStyle;
import com.ferox.util.Bag;

/**
 * ShadowMapGeneratorPass is a RenderPass that renders the depth values of
 * shadow casters into a shadow map from the perspective of a shadow-casting
 * light. Shadow maps generated by this pass are suitable for use with the
 * {@link ShadowedLightingPass}.
 * 
 * @author Michael Ludwig
 */
public class ShadowMapGeneratorPass extends AbstractFixedFunctionRenderPass {
    public ShadowMapGeneratorPass(RenderConnection connection, int maxMaterialTexUnits, String vertexBinding) {
        super(connection, maxMaterialTexUnits, vertexBinding, null, null);
    }

    @Override
    protected void render(FixedFunctionRenderer ffp) {
        // set style to be just depth, while drawing only back faces
        ffp.setColorWriteMask(false, false, false, false);
        ffp.setDrawStyle(DrawStyle.NONE, DrawStyle.SOLID);
        
        // move everything backwards slightly to account for floating errors
        ffp.setDepthOffsets(0f, 5f);
        ffp.setDepthOffsetsEnabled(true);
        
        Bag<Entity> shadowAtoms = connection.getShadowCastingEntities();
        int ct = shadowAtoms.size();
        for (int i = 0; i < ct; i++) {
            // we bypass the material setup normally used for render atoms
            renderGeometry(shadowAtoms.get(i));
        }
    }

    @Override
    protected Frustum getFrustum() {
        return connection.getShadowFrustum();
    }

    @Override
    protected void configureViewport(FixedFunctionRenderer renderer, Surface surface) {
        renderer.setViewport(0, 0, surface.getWidth(), surface.getHeight());
        renderer.clear(true, true, true, surface.getClearColor(), surface.getClearDepth(), surface.getClearStencil());
    }

    @Override
    protected void notifyPassBegin() {
        connection.notifyShadowMapBegin();
    }

    @Override
    protected void notifyPassEnd() {
        connection.notifyShadowMapEnd();
    }
}
